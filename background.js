//only discard after (in minutes)
const discardAfterMinutes = 10;
//do not discard the following domains
const doNotDiscard = [];
//example
//const doNotDiscard = ['mail.example.com','domain.com', 'www.anotherdomain.net'];

//log basic info
const log = true;
//log debug info
const debug = false;

//only discard http/https tabs - tabs with blank urls, local paths or chrome:// (eg: chrome://settings) are not discarded
const onlyDiscardTabsWithUrlPattern = /^((http|https):\/\/)/;
//only discards tabs that are autoDiscardable with status 'complete' (finished loading) and that have not been discarded
const tabsQueryOptions = { autoDiscardable: true, status: 'complete', discarded: false };

const minutesDiscard = discardAfterMinutes * 60 * 1000;
var trackTabs = [];
var tmpTabs = [];
var lastActiveTab = 0;

//Fired when the extension is first installed, when the extension is updated to a new version, 
//and when Chrome is updated to a new version. - https://developer.chrome.com/docs/extensions/reference/runtime/#event-onInstalled
chrome.runtime.onInstalled.addListener(() => {
  
  if(debug || log){ console.log('start: '+new Date().toLocaleString()); }
  
  trackTabs = [];
  chrome.alarms.clearAll();
  chrome.idle.onStateChanged.removeListener();
  
  //there is no need for the extension to be running when device is sleeping or idle
  //when idled for longer than discardAfterMinutes + 2 stop running attemptDiscards()
  //the +2 to give enough time for all discardable tabs to be discarded
  chrome.idle.setDetectionInterval((parseInt(discardAfterMinutes)+2)*60);
  //Fired when the idle time (set above) is reached or on change status (active, idle, locked)
  chrome.idle.onStateChanged.addListener(
      function (state) {
          if(log){ console.log('Browser state change '+new Date().toLocaleString()); }
          if (state === "active"){
            chrome.alarms.create("everyMinute", { periodInMinutes: 1 });
            if(debug || log){ console.log('Active: started!'); }
          }else{
            chrome.alarms.clearAll();
            if(debug || log){ console.log('Stop: '+state+'!'); }
          }
      }
  );
  
  //start the alarm to trigger every minute
  //chrome.alarms are recurring events that are triggered every periodInMinutes
  //maximum once per minute - read: https://developer.chrome.com/docs/extensions/reference/alarms/
  //'everyMinute' is the name I gave this alarm, it could be anything else
  chrome.alarms.create("everyMinute", { periodInMinutes: 1 });
  
  //first run to populate trackTabs
  attemptDiscards();
  
});

//get tabs match tabsQueryOptions 
async function getTabs() {
  try {
    return await chrome.tabs.query(tabsQueryOptions);
  } catch (error) {
    console.log('Failed to query chrome.tabs',error);
    return [];
  }
}

//main function - populates/updates/cleans trackTabs and discards tabs over discardAfterMinutes
async function attemptDiscards(){
  
  if(debug || log){ console.log('Running: '+new Date().toLocaleString()); }
  
  let tabs = await getTabs();
  
  //using tmpTabs to cleanup trackTabs generated by the onActivated listener (read below)
  //duplicate trackTabs object
  //Using the Spread { ...objectName } method as shallow copy is all it's needed (JS array/object duplication is grrr)
  tmpTabs = { ...trackTabs }
  const time = new Date().getTime();
  
  for (let tab of tabs) {
    
    //non http/https
    if(!onlyDiscardTabsWithUrlPattern.test(tab.url)){
      if(debug){ console.log('Tab non http/https: '+tab.id+' '+tab.url); }
      continue;
    }
    
    //extract domain from url
    var domain = new URL(tab.url).hostname;
    
    //skip domains in excludes list
    if (doNotDiscard.includes(domain)) {
      if(debug){ console.log('Tab doNotDiscard: '+tab.id+' '+domain); }
      continue;
    }
    
    if(tmpTabs[tab.id]){
      delete tmpTabs[tab.id];
    }
    
    if(tab.active){
      
      //tab is active, so start tracking or update last active time to now
      trackTabs[tab.id] = new Date().getTime();
      lastActiveTab = tab.id;
      if(debug){ console.log('Update time of active tab: '+tab.id+' '+domain); }
      
    }
    //tab is already being tracked
    else if(trackTabs[tab.id]){
      
      //is over discard time?
      if (time - trackTabs[tab.id] > minutesDiscard) {
        
          //try discard
          //this can fail for several reasons, example: the user made the tab active since the query started
          try {
            chrome.tabs.discard(tab.id);
            delete trackTabs[tab.id];
            if(debug || log){ console.log('Discarded '+tab.id+' '+domain); }
          } catch (error) {
            if(debug || log){ console.log('Failed to discard '+tab.id+' '+domain); }
          }
        
      }
    }
    //tab is not tracked yet
    //this happens when first starting or if the url changed on a tab (from a non to a discardable url)
    else{
    
        //start tracking tab
        trackTabs[tab.id] = new Date().getTime();
        if(debug || log){ console.log('Tracking tab: '+tab.id+' '+domain); }
      
    }
    
  }
  
  //cleanup trackTabs
  for (var x in tmpTabs) {
      if(trackTabs[x]){
        delete trackTabs[x];
        if(debug){ console.log('Cleanup from trackTabs the tab: '+x); }
      }
  }
  
  if(debug){
    console.log('trackTabs ', trackTabs);
    console.log('tmpTabs ', tmpTabs);
    console.log('attemptDiscards() finished: '+new Date().toLocaleString());
  }
  
}

//when alarm is triggered
chrome.alarms.onAlarm.addListener((alarm) => {
  //the only reason for this if is in case multiple alarms are set in the future
  if (alarm.name == "everyMinute") {
    attemptDiscards();
  }
});

//when new tab is activated
chrome.tabs.onActivated.addListener((activeInfo) => {
  
  //as we have changed the active tab, test if lastActiveTab is in trackTabs
  if(trackTabs[lastActiveTab]){
    //as the active tab changed just now, update the lastActiveTab time
    trackTabs[lastActiveTab] = new Date().getTime();
  }
  
  //start tracking tab or update active time
  //validation/removal of tab from tracking will be executed on the next attemptDiscards()
  //skipping validation here reduces resource usage every time a new tab is active
  //plus the url may not be set at the time this event fired
  trackTabs[activeInfo.tabId] = new Date().getTime();
  
  //current active tab becomes the lastActiveTab
  lastActiveTab = activeInfo.tabId;
  if(debug){ console.log('Updated active tab time '+activeInfo.tabId); }
  
});

//When a tab is closed
chrome.tabs.onRemoved.addListener((removeInfo) => {
  
  if(trackTabs[removeInfo]){
    //stop tracking tab
    delete trackTabs[removeInfo];
    if(debug){ console.log('Tab was closed '+removeInfo); }
  }else{
    if(debug){ console.log('Closed untracked tab '+removeInfo); }
  }
  
});
